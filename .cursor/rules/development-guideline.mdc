---
description: 
globs: 
alwaysApply: true
---
# ðŸŽ¯ CURSOR RULES - A17.chat Development Guidelines

## ðŸ“‹ **MANDATORY DEVELOPMENT PRINCIPLES**

### **EXPERT SOFTWARE DEVELOPER STANDARDS**
- Write concise, efficient, and maintainable code
- ALWAYS COMMENT YOUR CODE with JSDoc3 style documentation
- NEVER ERASE OLD COMMENTS if they are still useful
- Focus on "why" and "how" rather than just "what" in comments
- Use clear, descriptive variable and function names
- Follow established patterns and conventions consistently

### **LOGGING REQUIREMENTS**
- Use Winston for all logging (create modular Winston logging file)
- Log EVERY logical connection and workflow in the codebase
- Use appropriate logging levels (error, warn, info, debug)
- Include performance timing for API operations
- Log AI model selection and system prompt usage

---

## ðŸ—ï¸ **TECHNOLOGY STACK ADHERENCE**

### **CORE TECHNOLOGIES - NEVER DEVIATE**
```typescript
// Framework & Runtime
- Next.js 15.1.5 (App Router ONLY)
- React 19.0.0 with TypeScript 5.7.3
- Edge Runtime for API routes
- Turbopack for development builds

// AI & Machine Learning
- Vercel AI SDK for LLM integration
- Supported providers: Anthropic, OpenAI, Groq, DeepSeek
- Real-time streaming with streamText()

// Database & State
- Dexie.js (IndexedDB) for client-side persistence
- dexie-react-hooks for reactive queries
- nanoid for ID generation
- React state for UI, persistent state for data

// Styling & UI
- Tailwind CSS 3.4.17 with SEMANTIC color system
- Inter (primary) + Bricolage Grotesque (display) fonts
- tailwind-scrollbar plugin for custom scrollbars
```

### **PACKAGE VERSIONS - EXACT MATCHES REQUIRED**
```json
{
  "@ai-sdk/anthropic": "^1.1.2",
  "@ai-sdk/deepseek": "^0.1.2", 
  "@ai-sdk/groq": "^1.1.2",
  "@ai-sdk/openai": "^1.1.2",
  "ai": "latest",
  "dexie": "^4.0.11",
  "dexie-react-hooks": "^1.1.7",
  "next": "15.1.5",
  "react": "^19.0.0",
  "tailwindcss": "^3.4.17"
}
```

---

## ðŸ“ **MANDATORY FILE STRUCTURE**

### **NEVER CREATE FILES OUTSIDE THESE PATTERNS**
```
src/
â”œâ”€â”€ app/                    # Next.js App Router only
â”‚   â”œâ”€â”€ api/               # Edge runtime API routes
â”‚   â”œâ”€â”€ [dynamic]/         # Dynamic routes with brackets
â”‚   â”œâ”€â”€ layout.tsx         # Root layout (fonts, providers)
â”‚   â””â”€â”€ page.tsx           # Page components
â”œâ”€â”€ components/            # Feature-based organization
â”‚   â”œâ”€â”€ chat/              # Chat domain components
â”‚   â”œâ”€â”€ layout/            # Layout primitives
â”‚   â”œâ”€â”€ markdown/          # Markdown rendering
â”‚   â””â”€â”€ ui/                # Reusable UI primitives
â”œâ”€â”€ hooks/                 # Custom React hooks only
â”œâ”€â”€ lib/                   # Utilities and config
â”‚   â”œâ”€â”€ constants/         # Static configurations
â”‚   â””â”€â”€ *.ts               # Utility functions
â””â”€â”€ types/                 # TypeScript definitions only
```

### **FILE NAMING CONVENTIONS - STRICTLY ENFORCED**
- Components: `PascalCase.tsx` (e.g., `ChatMessage.tsx`)
- Hooks: `useCamelCase.ts` (e.g., `usePersistentChat.ts`)
- Utilities: `camelCase.ts` (e.g., `db.ts`, `models.ts`)
- Types: `camelCase.ts` (e.g., `models.ts`, `database.ts`)
- API Routes: `route.ts` (Next.js App Router standard)

---

## ðŸŽ¨ **FLEXIBLE COLOR SYSTEM RULES**

### **SEMANTIC COLOR STRUCTURE - MANDATORY PATTERN**
```typescript
// ALWAYS use these semantic color names in tailwind.config.ts
colors: {
  // PRIMARY SEMANTIC COLORS (Required)
  background: "your-theme-background-color",
  foreground: "your-theme-text-color",
  primary: "your-theme-primary-action-color",
  secondary: "your-theme-secondary-surface-color",
  accent: "your-theme-accent-highlight-color",
  muted: "your-theme-muted-disabled-color",
  border: "your-theme-border-separator-color",
  
  // STATE SEMANTIC COLORS (Required)
  success: "your-theme-success-color",
  warning: "your-theme-warning-color", 
  error: "your-theme-error-color",
  info: "your-theme-info-color",
  
  // EXTENDED SEMANTIC COLORS (Optional but recommended)
  card: "your-theme-card-background",
  popover: "your-theme-popover-background",
  destructive: "your-theme-destructive-action",
  ring: "your-theme-focus-ring",
}
```

### **COLOR USAGE PATTERNS - STRICTLY ENFORCED**
```css
/* ALWAYS use semantic class names, NEVER hardcoded colors */

/* âœ… CORRECT - Semantic color usage */
bg-background text-foreground
bg-primary text-primary-foreground
border-border text-muted
bg-success text-success-foreground
bg-error text-error-foreground

/* âŒ FORBIDDEN - Hardcoded colors */
bg-blue-500 text-red-400
bg-gray-800 text-white
border-slate-300 text-zinc-600
```

### **THEME IMPLEMENTATION REQUIREMENTS**
1. **All colors MUST be defined in `tailwind.config.ts`**
2. **Use CSS custom properties for theme switching capability**
3. **Maintain consistent contrast ratios (WCAG 2.1 AA minimum)**
4. **Support both light and dark mode variants**
5. **Test accessibility with chosen color scheme**

### **EXAMPLE FLEXIBLE THEME STRUCTURE**
```typescript
// tailwind.config.ts - Example implementation
const colors = {
  // Your chosen theme colors here (any palette)
  yourTheme: {
    bg: "#your-background",
    text: "#your-text", 
    primary: "#your-primary",
    secondary: "#your-secondary",
    accent: "#your-accent",
    muted: "#your-muted",
    border: "#your-border",
    success: "#your-success",
    warning: "#your-warning",
    error: "#your-error",
    info: "#your-info",
  }
};

export default {
  theme: {
    extend: {
      colors: {
        // Map semantic names to your theme
        background: colors.yourTheme.bg,
        foreground: colors.yourTheme.text,
        primary: colors.yourTheme.primary,
        secondary: colors.yourTheme.secondary,
        accent: colors.yourTheme.accent,
        muted: colors.yourTheme.muted,
        border: colors.yourTheme.border,
        success: colors.yourTheme.success,
        warning: colors.yourTheme.warning,
        error: colors.yourTheme.error,
        info: colors.yourTheme.info,
      },
    },
  },
}
```

---

## ðŸ”§ **CODE QUALITY REQUIREMENTS**

### **TYPESCRIPT STANDARDS - NON-NEGOTIABLE**
```typescript
// TypeScript configuration adherence
- Target: ES2017 (configured in tsconfig.json)
- Strict mode: true (no any types allowed)
- Path mapping: @/* for src/* imports
- JSX: preserve mode for Next.js

// Type patterns to follow
- Interface over type for object shapes
- Const assertions for immutable data
- Utility types: Omit, Pick, Partial, etc.
- Proper return type annotations for functions
```

### **IMPORT ORDER - ALWAYS FOLLOW**
```typescript
// 1. Third-party libraries
import { NextRequest } from "next/server";
import { useChat } from "ai/react";

// 2. Internal utilities and types  
import { db } from "@/lib/db";
import { ModelId } from "@/types/models";

// 3. Components (UI before business logic)
import { Button } from "@/components/ui/Button";
import { ChatMessage } from "@/components/chat/ChatMessage";

// 4. Relative imports
import "./styles.css";
```

### **COMMENTING STANDARDS - MANDATORY**
```typescript
/**
 * JSDoc3 style for functions and classes
 * @param {string} provider - The AI provider name
 * @returns {void}
 * @throws {Error} If API key is not defined
 */
function validateProviderApiKey(provider: string): void {
  // Inline comments for complex logic
  switch (provider) {
    case "anthropic":
      // Check for Anthropic API key configuration
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY is not defined");
      }
      break;
  }
}
```

---

## ðŸ¤– **AI INTEGRATION PATTERNS**

### **MODEL MANAGEMENT - FOLLOW EXACTLY**
```typescript
// Always use ModelRegistry from lib/constants/models.ts
const modelConfig = ModelRegistry[model as ModelId];

// Provider validation pattern
function validateProviderApiKey(provider: string): void {
  // Environment variable validation for each provider
}

// Streaming pattern
const result = streamText({
  model: provider(modelId),
  messages: messagesWithSystem,
});
```

### **SYSTEM PROMPT PATTERNS**
```typescript
// Always determine prompts dynamically
const determineSystemPrompt = (content: string): string => {
  const lowerContent = content.toLowerCase();
  
  // Programming keywords
  if (lowerContent.includes("code") || lowerContent.includes("programming")) {
    return "programmer";
  }
  
  // Math keywords  
  if (lowerContent.includes("math") || lowerContent.includes("calculate")) {
    return "math";
  }
  
  return "default";
};
```

### **ERROR HANDLING - MANDATORY PATTERN**
```typescript
try {
  // AI operation
  const result = await streamText({...});
  console.log(`[API] Request completed in ${endTime - startTime}ms`);
  return result.toDataStreamResponse();
} catch (error) {
  console.error("Error in chat API:", error);
  console.error(`Request failed after ${endTime - startTime}ms`);
  
  return new Response(
    JSON.stringify({
      error: "An error occurred during the request.",
      details: error instanceof Error ? error.message : "Unknown error",
    }),
    {
      status: 500,
      headers: {
        "Content-Type": "application/json",
        "Cache-Control": "no-store",
      },
    }
  );
}
```

---

## ðŸ’¾ **DATABASE PATTERNS**

### **DEXIE USAGE - REQUIRED PATTERNS**
```typescript
// Database class extension
class ChatDatabase extends Dexie {
  chats!: Table<Chat>;
  messages!: Table<StoredMessage>;

  constructor() {
    super("ChatDatabase");
    this.version(1).stores({
      chats: "id, created_at, updated_at",
      messages: "id, chatId, created_at",
    });
  }
}

// Reactive queries with error handling
const storedMessages = useLiveQuery(async () => {
  if (!chatId) return [];
  return await db.getChatMessages(chatId);
}, [chatId]);
```

### **ID GENERATION**
```typescript
// Always use nanoid for IDs
import { nanoid } from "nanoid";

const id = nanoid(); // For all entity IDs
```

---

## ðŸ” **SECURITY & MIDDLEWARE**

### **SECURITY HEADERS - MANDATORY FOR ALL API ROUTES**
```typescript
// middleware.ts pattern - always include
response.headers.set("Strict-Transport-Security", "max-age=63072000");
response.headers.set("Access-Control-Allow-Origin", "*");
response.headers.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
response.headers.set("Cache-Control", "public, max-age=0, must-revalidate");
```

### **API ROUTE CONFIGURATION**
```typescript
// Always include these exports for API routes
export const runtime = "edge";
export const dynamic = "force-dynamic"; 
export const maxDuration = 300;
```

---

## ðŸ“± **COMPONENT PATTERNS**

### **REACT COMPONENT STRUCTURE**
```typescript
// Always use this structure for components
interface ComponentProps {
  // Props with proper TypeScript types
}

export function ComponentName({ prop1, prop2 }: ComponentProps) {
  // Hooks at top
  const [state, setState] = useState();
  const customHook = useCustomHook();
  
  // Event handlers
  const handleEvent = useCallback(() => {
    // Handler logic with error handling
  }, [dependencies]);
  
  // Early returns for loading/error states
  if (loading) return <LoadingComponent />;
  if (error) return <ErrorComponent error={error} />;
  
  // Main render with SEMANTIC color classes
  return (
    <div className="bg-background text-foreground border-border">
      <button className="bg-primary text-primary-foreground hover:bg-primary/90">
        {/* Component content */}
      </button>
    </div>
  );
}
```

### **CUSTOM HOOKS PATTERN**
```typescript
// Always follow this structure for custom hooks
export function useCustomHook(options: HookOptions) {
  const [state, setState] = useState();
  const [error, setError] = useState<Error | null>(null);
  
  // External hooks
  const externalHook = useExternalHook();
  
  // Callbacks with dependency arrays
  const memoizedCallback = useCallback(() => {
    // Implementation with error handling
  }, [dependencies]);
  
  // Return object with consistent naming
  return {
    data: state,
    error,
    isLoading: loading,
    methods: { memoizedCallback },
  };
}
```

---

## ðŸš€ **PERFORMANCE REQUIREMENTS**

### **NEXT.JS OPTIMIZATIONS - ALWAYS IMPLEMENT**
```typescript
// next.config.ts requirements
{
  experimental: {
    serverActions: { bodySizeLimit: '2mb' }
  },
  typescript: { ignoreBuildErrors: false },
  eslint: { ignoreDuringBuilds: false },
  compiler: { 
    removeConsole: process.env.NODE_ENV === "production" 
  },
  reactStrictMode: true,
  compress: true
}
```

### **PERFORMANCE MONITORING**
```typescript
// Always include timing for API operations
const startTime = performance.now();
// ... operation
const endTime = performance.now();
console.log(`[API] Operation completed in ${endTime - startTime}ms`);
```

---

## âŒ **FORBIDDEN PRACTICES**

### **NEVER DO THESE**
- Create files outside the established structure
- Use hardcoded color classes (bg-blue-500, text-red-400, etc.)
- Use colors outside the defined semantic system
- Create temporary files or helper scripts
- Use `any` type in TypeScript
- Create documentation files unless explicitly requested
- Deviate from the package.json dependencies
- Use non-Edge runtime for API routes
- Skip error handling in async operations
- Remove existing useful comments

### **ALWAYS DO THESE**
- Follow the exact file naming conventions
- Use TypeScript strict mode
- Include JSDoc3 comments for all functions
- Implement proper error boundaries
- Use Winston logging for all operations
- Follow the import order hierarchy
- Validate environment variables
- Include performance timing
- Use semantic HTML and accessibility features
- Follow the established component patterns
- **Use ONLY semantic color classes from your defined theme**

---

## ðŸŽ¯ **COLOR SYSTEM COMPLETION CRITERIA**

### **EVERY COLOR USAGE MUST**
1. Use semantic color names (background, foreground, primary, etc.)
2. Be defined in tailwind.config.ts with proper mapping
3. Support theme switching if multiple themes are needed
4. Meet accessibility contrast requirements
5. Follow the established semantic structure
6. Never use hardcoded Tailwind color utilities
7. Support both light and dark variants if needed
8. Be documented in the theme configuration

### **THEME FLEXIBILITY GUIDELINES**
- **Structure**: Always maintain the semantic color structure
- **Naming**: Use consistent semantic naming across all themes
- **Implementation**: Map your chosen colors to semantic names
- **Accessibility**: Ensure proper contrast ratios for your color choices
- **Consistency**: Apply colors consistently across all components

---

## ðŸš€ **FEATURE DEVELOPMENT WORKFLOW**

### **NEW FEATURE DEVELOPMENT - MANDATORY PROCESS**

#### **1. PLANNING PHASE - ALWAYS START HERE**
```typescript
// Before writing ANY code, determine:

1. **Feature Scope Analysis**
   - What domain does this feature belong to? (chat, ui, layout, etc.)
   - Does it need new API endpoints?
   - Does it require database changes?
   - Will it need new types/interfaces?

2. **Architecture Decision**
   - Where in the file structure does this belong?
   - What existing patterns can be reused?
   - What new patterns might be needed?
   - How does it integrate with existing state management?

3. **Dependencies Assessment**  
   - What existing components/hooks can be reused?
   - Do we need new package dependencies?
   - How does it affect the current bundle size?
```

#### **2. FILE STRUCTURE DECISION TREE**

```typescript
// FEATURE TYPE â†’ FILE LOCATION MAPPING

ðŸ¤– AI/Chat Related Features:
â”œâ”€â”€ API Logic â†’ src/app/api/[feature]/route.ts
â”œâ”€â”€ Chat Components â†’ src/components/chat/[FeatureName].tsx  
â”œâ”€â”€ Chat Hooks â†’ src/hooks/use[FeatureName].ts
â”œâ”€â”€ AI Types â†’ src/types/[feature].ts
â””â”€â”€ Constants â†’ src/lib/constants/[feature].ts

ðŸŽ¨ UI/Design System Features:
â”œâ”€â”€ Reusable Components â†’ src/components/ui/[ComponentName].tsx
â”œâ”€â”€ Layout Components â†’ src/components/layout/[ComponentName].tsx
â”œâ”€â”€ Styling â†’ Update tailwind.config.ts semantic colors
â””â”€â”€ UI Types â†’ src/types/ui.ts

ðŸ“Š Data/Database Features:  
â”œâ”€â”€ Database Schema â†’ src/lib/db.ts (extend existing classes)
â”œâ”€â”€ Database Types â†’ src/types/database.ts
â”œâ”€â”€ Data Hooks â†’ src/hooks/use[DataName].ts
â””â”€â”€ Utilities â†’ src/lib/[utilityName].ts

ðŸ”§ Core/Infrastructure Features:
â”œâ”€â”€ Middleware â†’ src/middleware.ts (extend existing)
â”œâ”€â”€ Configuration â†’ next.config.ts, tailwind.config.ts
â”œâ”€â”€ Utils â†’ src/lib/[utilityName].ts
â””â”€â”€ Types â†’ src/types/[coreName].ts
```

#### **3. COMPONENT CREATION WORKFLOW**

```typescript
// STEP-BY-STEP COMPONENT CREATION PROCESS

**Step 1: Determine Component Type**
- Is it a page component? â†’ src/app/[route]/page.tsx
- Is it a reusable UI primitive? â†’ src/components/ui/
- Is it feature-specific? â†’ src/components/[domain]/
- Is it a layout component? â†’ src/components/layout/

**Step 2: Create Interface First**
// Always start with TypeScript interface
interface [ComponentName]Props {
  // Define all props with proper types
  title: string;
  onAction?: () => void;
  variant?: 'primary' | 'secondary';
  children?: React.ReactNode;
}

**Step 3: Component Structure Template**
import { useState, useCallback } from 'react';
// ... other imports in correct order

/**
 * [ComponentName] - Brief description of component purpose
 * @param props - Component props
 * @returns JSX.Element
 */
export function [ComponentName]({ 
  title, 
  onAction, 
  variant = 'primary',
  children 
}: [ComponentName]Props) {
  // 1. Hooks first
  const [localState, setLocalState] = useState();
  
  // 2. Custom hooks
  const customHook = useCustomHook();
  
  // 3. Event handlers
  const handleClick = useCallback(() => {
    // Implementation with error handling
    try {
      onAction?.();
    } catch (error) {
      console.error('Error in handleClick:', error);
    }
  }, [onAction]);
  
  // 4. Early returns for loading/error states
  if (customHook.isLoading) return <LoadingSpinner />;
  if (customHook.error) return <ErrorMessage error={customHook.error} />;
  
  // 5. Main render with semantic classes
  return (
    <div className="bg-background text-foreground border-border">
      <h2 className="text-foreground font-display">{title}</h2>
      <button 
        onClick={handleClick}
        className={`
          bg-${variant === 'primary' ? 'primary' : 'secondary'} 
          text-${variant === 'primary' ? 'primary' : 'secondary'}-foreground
          hover:opacity-90 transition-opacity
        `}
      >
        {children}
      </button>
    </div>
  );
}

**Step 4: Export Pattern**
// Named export for components
export { [ComponentName] };
// Default export only for pages
export default [ComponentName]; // Only for page.tsx files
```

#### **4. CUSTOM HOOK CREATION WORKFLOW**

```typescript
// WHEN TO CREATE A CUSTOM HOOK
- Managing component state across multiple components
- Encapsulating complex logic with side effects
- Integrating with external APIs or services
- Managing subscriptions or data fetching

// CUSTOM HOOK TEMPLATE
/**
 * use[FeatureName] - Description of hook purpose
 * @param options - Hook configuration options
 * @returns Hook return object with consistent naming
 */
export function use[FeatureName](options: [FeatureName]Options) {
  // 1. State declarations
  const [data, setData] = useState<[DataType] | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // 2. External hooks (if needed)
  const router = useRouter();
  const existingHook = useExistingHook();
  
  // 3. Core logic functions
  const fetchData = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // Implementation
      const result = await apiCall(options);
      setData(result);
      
    } catch (err) {
      console.error('Error in fetchData:', err);
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      setIsLoading(false);
    }
  }, [options]);
  
  // 4. Effects
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  // 5. Return object with consistent naming
  return {
    // Data
    data,
    isLoading,
    error,
    
    // Actions
    refetch: fetchData,
    reset: () => {
      setData(null);
      setError(null);
    },
    
    // Computed values
    hasData: !!data,
    isEmpty: !data || (Array.isArray(data) && data.length === 0),
  };
}
```

#### **5. API ROUTE DEVELOPMENT WORKFLOW**

```typescript
// API ROUTE CREATION PROCESS

**Step 1: Route Location**
- RESTful endpoints â†’ src/app/api/[resource]/route.ts
- Nested resources â†’ src/app/api/[resource]/[id]/route.ts
- Action endpoints â†’ src/app/api/[resource]/[action]/route.ts

**Step 2: API Route Template**
import { NextRequest } from 'next/server';
// ... other imports

// Always include these for API routes
export const runtime = "edge";
export const dynamic = "force-dynamic";
export const maxDuration = 300;

/**
 * [HTTP_METHOD] /api/[route] - Description of endpoint
 * @param req - Next.js request object
 * @returns Response with proper headers and error handling
 */
export async function [HTTP_METHOD](req: NextRequest) {
  const startTime = performance.now();
  
  try {
    // 1. Input validation
    const body = await req.json();
    const { param1, param2 } = body;
    
    if (!param1) {
      return new Response(
        JSON.stringify({ error: "param1 is required" }),
        { 
          status: 400,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    
    // 2. Business logic
    console.log(`[API] Processing ${req.url} with params:`, { param1, param2 });
    
    const result = await businessLogic(param1, param2);
    
    // 3. Success response
    const endTime = performance.now();
    console.log(`[API] Request completed in ${endTime - startTime}ms`);
    
    return new Response(
      JSON.stringify({ data: result }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-store, must-revalidate",
        },
      }
    );
    
  } catch (error) {
    // 4. Error handling
    const endTime = performance.now();
    console.error(`[API] Error in ${req.url}:`, error);
    console.error(`Request failed after ${endTime - startTime}ms`);
    
    return new Response(
      JSON.stringify({
        error: "Internal server error",
        details: error instanceof Error ? error.message : "Unknown error",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-store",
        },
      }
    );
  }
}
```

#### **6. DATABASE SCHEMA CHANGES WORKFLOW**

```typescript
// DATABASE MODIFICATION PROCESS

**Step 1: Assess Change Type**
- New table? â†’ Add to db.ts class definition
- New fields? â†’ Update existing interface
- New relationships? â†’ Update query methods

**Step 2: Update Database Class**
// In src/lib/db.ts
class ChatDatabase extends Dexie {
  chats!: Table<Chat>;
  messages!: Table<StoredMessage>;
  [newTable]!: Table<[NewType]>; // Add new table

  constructor() {
    super("ChatDatabase");
    
    // Increment version for schema changes
    this.version(2).stores({
      chats: "id, created_at, updated_at",
      messages: "id, chatId, created_at",
      [newTable]: "id, [indexedField], created_at", // Add new table schema
    });
  }
  
  // Add new methods for the table
  async create[NewEntity](data: Omit<[NewType], "id" | "created_at">): Promise<[NewType]> {
    const entity: [NewType] = {
      ...data,
      id: nanoid(),
      created_at: new Date(),
    };
    
    await this.[newTable].add(entity);
    return entity;
  }
}

**Step 3: Update Types**
// In src/types/database.ts
export interface [NewType] {
  id: string;
  [field]: string;
  created_at: Date;
  updated_at?: Date;
}
```

#### **7. TYPE DEFINITION WORKFLOW**

```typescript
// TYPE CREATION GUIDELINES

**Step 1: Determine Type Location**
- Database types â†’ src/types/database.ts
- API types â†’ src/types/api.ts  
- Component props â†’ src/types/components.ts
- Domain-specific â†’ src/types/[domain].ts

**Step 2: Type Definition Patterns**
// Use interfaces for object shapes
export interface [EntityName] {
  id: string;
  [field]: [Type];
  created_at: Date;
  updated_at?: Date;
}

// Use type aliases for unions and computed types  
export type [StatusType] = 'pending' | 'completed' | 'failed';
export type [EntityWithId] = [Entity] & { id: string };

// Use const assertions for immutable data
export const [CONSTANTS] = {
  [KEY]: 'value',
} as const;

export type [ConstantKeys] = keyof typeof [CONSTANTS];

**Step 3: Export Patterns**
// Named exports only
export { [TypeName] };
export type { [InterfaceName] };
```

---

## ðŸ”„ **INTEGRATION PATTERNS**

### **INTEGRATING WITH EXISTING SYSTEMS**

#### **1. STATE MANAGEMENT INTEGRATION**
```typescript
// When adding features that need state:

**Local State (useState)**
- Component-specific UI state
- Form inputs and validation
- Temporary display states

**Custom Hooks (useCustomHook)**  
- Complex state logic
- Side effects management
- Data fetching and caching

**Dexie Database (useLiveQuery)**
- Persistent data storage
- Cross-session data
- User-generated content

**URL State (useRouter)**
- Navigation state
- Shareable application state
- Deep linking support
```

#### **2. AI INTEGRATION PATTERN**
```typescript
// When adding AI-powered features:

**Step 1: Extend Model Registry**
// In src/lib/constants/models.ts
export const ModelRegistry = {
  // ... existing models
  "new-model-id": {
    name: "New Model Name",
    contextWindow: 128000,
    provider: "provider-name",
  },
} as const;

**Step 2: Add System Prompts** 
// In src/lib/constants/prompts.ts
export const systemPrompts: SystemPrompt[] = [
  // ... existing prompts
  {
    id: "new-feature",
    name: "New Feature Assistant",
    content: `System prompt for new feature...`,
    description: "Description of new feature behavior",
  },
];

**Step 3: Extend Prompt Detection**
// In hooks/usePersistentChat.ts or new hook
const determineSystemPrompt = (content: string): string => {
  const lowerContent = content.toLowerCase();
  
  // Add new feature detection
  if (lowerContent.includes("new-feature-keyword")) {
    return "new-feature";
  }
  
  // ... existing logic
  return "default";
};
```

#### **3. UI CONSISTENCY PATTERNS**
```typescript
// When adding new UI components:

**Step 1: Check Existing Components**
- Can I extend an existing component?
- Is there a similar pattern already implemented?
- What semantic color classes are already in use?

**Step 2: Follow Design System**
- Use semantic color classes only
- Follow typography hierarchy (font-sans, font-display)
- Implement responsive design patterns
- Add proper accessibility attributes

**Step 3: Component Composition**
// Prefer composition over creating monolithic components
const [NewFeature] = () => {
  return (
    <Card className="bg-card border-border">
      <CardHeader>
        <Heading variant="h2">Feature Title</Heading>
      </CardHeader>
      <CardContent>
        <ExistingComponent />
        <NewSpecificComponent />
      </CardContent>
    </Card>
  );
};
```

---

## ðŸ“‹ **CODE REVIEW CHECKLIST**

### **BEFORE SUBMITTING - VERIFY ALL ITEMS**

#### **âœ… Architecture Compliance**
- [ ] Files are in correct locations per established structure
- [ ] Component naming follows PascalCase convention
- [ ] Hooks follow useCamelCase convention
- [ ] Imports are ordered correctly (3rd party â†’ internal â†’ components â†’ relative)

#### **âœ… Code Quality**
- [ ] All functions have JSDoc3 comments
- [ ] Complex logic has inline comments
- [ ] No `any` types used
- [ ] Error handling implemented for async operations
- [ ] Performance timing added for API operations

#### **âœ… UI/UX Standards**
- [ ] Only semantic color classes used (bg-background, text-foreground, etc.)
- [ ] No hardcoded colors (bg-blue-500, text-red-400, etc.)
- [ ] Responsive design implemented
- [ ] Accessibility attributes added (ARIA labels, semantic HTML)

#### **âœ… Integration Standards**
- [ ] State management pattern appropriate for use case
- [ ] Database changes include proper versioning
- [ ] API routes include proper error handling and headers
- [ ] Types are properly defined and exported

#### **âœ… Performance & Security**
- [ ] API routes use Edge runtime
- [ ] Security headers included
- [ ] Console logs appropriate for environment
- [ ] Bundle size impact considered

---


**REMEMBER**: The user must manually provide codebase files for reading. Always ask for specific files if you need them to complete a task. Focus on semantic color structure rather than specific color values - this allows for maximum theme flexibility while maintaining architectural consistency. 